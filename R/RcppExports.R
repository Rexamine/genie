# This file was generated by Rcpp::compileAttributes
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

hclust2 <- function(objects, distance = NULL) {
    .Call('DataStructures_hclust2', PACKAGE = 'DataStructures', objects, distance)
}

generateMergeMatrix <- function(x) {
    .Call('DataStructures_generateMergeMatrix', PACKAGE = 'DataStructures', x)
}

generateMergeMatrix2 <- function(x) {
    .Call('DataStructures_generateMergeMatrix2', PACKAGE = 'DataStructures', x)
}

#' @rdname mtree
#' @details
#' \code{mtree_create} creates an empty m-tree instance. Please use
#' \code{mtree_build} for populating the tree.
#'
#' @return
#' \code{mtree_create} returns a new, empty m-tree.
#' @param distance an R function, which calculates metric in the space
#' @param isSimilarity a logical value, does a distance function calculate
#' distance or similarity?
#' @param m single integer, maximum number of children can be in a node
#' in the tree
#' @param minm single integer, minimum number of children can be in a node
#' in the tree
#' @param maxLeafPointsCount single integer, maximum number of
#' points in a single leaf
#' @param vantageCandidatesCount single integer, number of candidates
#' considered as a vantage point in a single node. Too big number can
#' cause performance problem in building the tree, but too small can cause
#' performance problem when searching.
#' @param testPointsCount single integer, how many points are considered with
#' a single candidate for vantage point in a node to assess a variance of
#' distances
mtree_create <- function(distance, isSimilarity = FALSE) {
    .Call('DataStructures_mtree_create', PACKAGE = 'DataStructures', distance, isSimilarity)
}

#' @rdname mtree
#' @details
#' \code{mtree_insert} inserts a new point into a m-tree.
#' Calling this function n times has worse performance in comparison
#' to calling one \code{mtree_build} with n points in the beginning.
#'
#' @return
#' \code{mtree_insert} does not return anything interesting.
#' @param obj a point to insert
mtree_insert <- function(tree, obj) {
    invisible(.Call('DataStructures_mtree_insert', PACKAGE = 'DataStructures', tree, obj))
}

#' @rdname mtree
#' @details
#' \code{mtree_build} populates an empty tree with set of points. If called
#' for non-empty tree, whole structure of previous tree is deleted. This is
#' recommended way of building a tree (instead of inserts by
#' \code{mtree_insert}).
#'
#' @return
#' \code{mtree_build} does not return anything interesting.
#' @param listobj an R list, where every element of list is assumed as one
#' point in a  metric space
mtree_build <- function(tree, listobj) {
    invisible(.Call('DataStructures_mtree_build', PACKAGE = 'DataStructures', tree, listobj))
}

#' @rdname mtree
#' @details
#' \code{mtree_searchKNN} finds k nearest neighbours for a given object
#' in the tree.
#' Please use this function for objects, which are not in a set of points
#' inserted to the tree or which were used for building the tree. For these
#' cases please use \code{mtree_searchKNNKnown} or
#' \code{mtree_searchKNNKnownIndex} which can be faster.
#'
#' @return
#' \code{mtree_searchKNN} returns a list. First element of the list
#' is a list with found elements. A second element of the list is a list
#' with distances these objects from a given object.
#' @param p an R object for which neighbours are found
#' @param k a single integer, number of neighbours to find
#' @param findItself boolean value, should results contain an given object?
mtree_searchKNN <- function(tree, p, k, findItself = TRUE) {
    .Call('DataStructures_mtree_searchKNN', PACKAGE = 'DataStructures', tree, p, k, findItself)
}

#' @rdname mtree
#' @details
#' \code{mtree_searchRadius} finds neighbours for a given object
#' within a given radius in the tree.
#' Please use this function for objects, which are not in a set of points
#' inserted to the tree or which were used for building the tree. For these
#' cases please use \code{mtree_searchRadiusKnown} or
#' \code{mtree_searchRadiusKnownIndex} which can be faster.
#'
#' @return
#' \code{mtree_searchRadius} returns a list. First element of the list
#' is a list with found elements. A second element of the list is a list
#' with distances these objects from a given object.
#' @param p an R object for which neighbours are found
#' @param tau a float value, a radius
#' @param findItself boolean value, should results contain an given object?
mtree_searchRadius <- function(tree, p, tau, findItself = TRUE) {
    .Call('DataStructures_mtree_searchRadius', PACKAGE = 'DataStructures', tree, p, tau, findItself)
}

#' @rdname mvptree
#' @details
#' \code{mvptree_create} creates an empty m-tree instance. Please use
#' \code{mvptree_build} for populating the tree.
#'
#' @return
#' \code{mvptree_create} returns a new, empty m-tree.
#' @param distance an R function, which calculates metric in the space
#' @param isSimilarity a logical value, does a distance function calculate
#' distance or similarity?
#' @param m single integer, maximum number of children can be in a node
#' in the tree
#' @param minm single integer, minimum number of children can be in a node
#' in the tree
#' @param maxLeafPointsCount single integer, maximum number of
#' points in a single leaf
#' @param vantageCandidatesCount single integer, number of candidates
#' considered as a vantage point in a single node. Too big number can
#' cause performance problem in building the tree, but too small can cause
#' performance problem when searching.
#' @param testPointsCount single integer, how many points are considered with
#' a single candidate for vantage point in a node to assess a variance of
#' distances
mvptree_create <- function(distance, isSimilarity = FALSE, mvp_branchfactor = 2L, mvp_pathlength = 5L, mvp_leafcap = 25L) {
    .Call('DataStructures_mvptree_create', PACKAGE = 'DataStructures', distance, isSimilarity, mvp_branchfactor, mvp_pathlength, mvp_leafcap)
}

#' @rdname mvptree
#' @details
#' \code{mvptree_insert} inserts a new point into a m-tree.
#' Calling this function n times has worse performance in comparison
#' to calling one \code{mvptree_build} with n points in the beginning.
#'
#' @return
#' \code{mvptree_insert} does not return anything interesting.
#' @param obj a point to insert
mvptree_insert <- function(tree, obj) {
    invisible(.Call('DataStructures_mvptree_insert', PACKAGE = 'DataStructures', tree, obj))
}

#' @rdname mvptree
#' @details
#' \code{mvptree_build} populates an empty tree with set of points. If called
#' for non-empty tree, whole structure of previous tree is deleted. This is
#' recommended way of building a tree (instead of inserts by
#' \code{mvptree_insert}).
#'
#' @return
#' \code{mvptree_build} does not return anything interesting.
#' @param listobj an R list, where every element of list is assumed as one
#' point in a  metric space
mvptree_build <- function(tree, listobj) {
    invisible(.Call('DataStructures_mvptree_build', PACKAGE = 'DataStructures', tree, listobj))
}

#' @rdname mvptree
#' @details
#' \code{mvptree_searchKNN} finds k nearest neighbours for a given object
#' in the tree.
#' Please use this function for objects, which are not in a set of points
#' inserted to the tree or which were used for building the tree. For these
#' cases please use \code{mvptree_searchKNNKnown} or
#' \code{mvptree_searchKNNKnownIndex} which can be faster.
#'
#' @return
#' \code{mvptree_searchKNN} returns a list. First element of the list
#' is a list with found elements. A second element of the list is a list
#' with distances these objects from a given object.
#' @param p an R object for which neighbours are found
#' @param k a single integer, number of neighbours to find
#' @param findItself boolean value, should results contain an given object?
mvptree_searchKNN <- function(tree, p, k, findItself = TRUE) {
    .Call('DataStructures_mvptree_searchKNN', PACKAGE = 'DataStructures', tree, p, k, findItself)
}

#' @rdname mvptree
#' @details
#' \code{mvptree_searchRadius} finds neighbours for a given object
#' within a given radius in the tree.
#' Please use this function for objects, which are not in a set of points
#' inserted to the tree or which were used for building the tree. For these
#' cases please use \code{mvptree_searchRadiusKnown} or
#' \code{mvptree_searchRadiusKnownIndex} which can be faster.
#'
#' @return
#' \code{mvptree_searchRadius} returns a list. First element of the list
#' is a list with found elements. A second element of the list is a list
#' with distances these objects from a given object.
#' @param p an R object for which neighbours are found
#' @param tau a float value, a radius
#' @param findItself boolean value, should results contain an given object?
mvptree_searchRadius <- function(tree, p, tau, findItself = TRUE) {
    .Call('DataStructures_mvptree_searchRadius', PACKAGE = 'DataStructures', tree, p, tau, findItself)
}

#' @rdname queue
#' @details
#' \code{as.list.Queue} converts a given queue object to an R list.
#'
#' @return
#' \code{as.list.Queue} returns an R list object.
#' @param queue a queue object
as.list.Queue <- function(queue) {
    .Call('DataStructures_queue_as_list', PACKAGE = 'DataStructures', queue)
}

#' @rdname queue
#' @details
#' \code{queue_create} creates a new queue.
#'
#' @return
#' \code{queue_create} returns a new, empty queue.
queue_create <- function() {
    .Call('DataStructures_queue_create', PACKAGE = 'DataStructures')
}

#' @rdname queue
#' @details
#' \code{queue_empty} determines if a given queue is empty or not.
#'
#' @return
#' \code{queue_empty} returns a single logical value.
queue_empty <- function(queue) {
    .Call('DataStructures_queue_empty', PACKAGE = 'DataStructures', queue)
}

#' @rdname queue
#' @details
#' \code{queue_push} pushes a given object to the back of the queue.
#'
#' @return
#' \code{queue_push} does not return anything interesting.
#'
#' @param obj an R object
queue_push <- function(queue, obj) {
    invisible(.Call('DataStructures_queue_push', PACKAGE = 'DataStructures', queue, obj))
}

#' @rdname queue
#' @details
#' \code{queue_pop} pops an object from the top of the queue.
#'
#' @return
#' \code{queue_pop} returns an object at the top of te queue or
#' throws an error if the stack is empty.
queue_pop <- function(queue) {
    .Call('DataStructures_queue_pop', PACKAGE = 'DataStructures', queue)
}

#' @rdname stack
#' @details
#' \code{stack_create} creates a new stack.
#'
#' @return
#' \code{stack_create} returns a new, empty stack.
stack_create <- function() {
    .Call('DataStructures_stack_create', PACKAGE = 'DataStructures')
}

#' @rdname stack
#' @details
#' \code{as.list.Stack} converts a given stack object to an R list.
#'
#' @return
#' \code{as.list.Stack} returns an R list object.
#' @param stack a stack object
as.list.Stack <- function(stack) {
    .Call('DataStructures_stack_as_list', PACKAGE = 'DataStructures', stack)
}

#' @rdname stack
#' @details
#' \code{stack_empty} determines if a given stack is empty or not.
#'
#' @return
#' \code{stack_empty} returns a single logical value.
stack_empty <- function(stack) {
    .Call('DataStructures_stack_empty', PACKAGE = 'DataStructures', stack)
}

#' @rdname stack
#' @details
#' \code{stack_push} pushes a given object to the top of the stack.
#'
#' @return
#' \code{stack_push} does not return anything interesting.
#'
#' @param obj an R object
stack_push <- function(stack, obj) {
    invisible(.Call('DataStructures_stack_push', PACKAGE = 'DataStructures', stack, obj))
}

#' @rdname stack
#' @details
#' \code{stack_pop} pops an object from the top of the stack.
#'
#' @return
#' \code{stack_pop} returns an object at the top of te stack or
#' throws an error if the stack is empty.
stack_pop <- function(stack) {
    .Call('DataStructures_stack_pop', PACKAGE = 'DataStructures', stack)
}

#' @rdname vector
#' @details
#' \code{as.list.Vector} converts a given vector object to an R list.
#'
#' @return
#' \code{as.list.Vector} returns an R list object.
#' @param vec a vector object
as.list.Vector <- function(vec) {
    .Call('DataStructures_vector_as_list', PACKAGE = 'DataStructures', vec)
}

#' @rdname vector
#' @details
#' \code{vector_create} creates a new vector.
#'
#' @return
#' \code{vector_create} returns a new, empty vector.
vector_create <- function(n = 0L) {
    .Call('DataStructures_vector_create', PACKAGE = 'DataStructures', n)
}

#' @rdname vector
#' @details
#' \code{vector_empty} determines if a given stack is empty or not.
#'
#' @return
#' \code{vector_empty} returns a single logical value.
vector_empty <- function(vec) {
    .Call('DataStructures_vector_empty', PACKAGE = 'DataStructures', vec)
}

#' @rdname vector
#' @details
#' \code{vector_size} returns a size of vector.
#'
#' @return
#' \code{vector_size} returns a single integer value.
vector_size <- function(vec) {
    .Call('DataStructures_vector_size', PACKAGE = 'DataStructures', vec)
}

#' @rdname vector
#' @details
#' \code{vector_front} returns the first object of a given vector.
#'
#' @return
#' \code{vector_front} returns a single RObject value or
#' throws an error if a vector is empty.
vector_front <- function(vec) {
    .Call('DataStructures_vector_front', PACKAGE = 'DataStructures', vec)
}

#' @rdname vector
#' @details
#' \code{vector_back} returns the last object of a given vector.
#'
#' @return
#' \code{vector_back} returns a single RObject value or
#' throws an error if a vector is empty.
vector_back <- function(vec) {
    .Call('DataStructures_vector_back', PACKAGE = 'DataStructures', vec)
}

#' @rdname stack
#' @details
#' \code{vector_push_back} pushes a given object at the end of the vector.
#'
#' @return
#' \code{vector_push_back} does not return anything interesting.
#'
#' @param obj an R object
vector_push_back <- function(vec, obj) {
    invisible(.Call('DataStructures_vector_push_back', PACKAGE = 'DataStructures', vec, obj))
}

#' @rdname stack
#' @details
#' \code{vector_pop_back} removes the last element in the vector, effectively
#' reducing the container size by one.
#'
#' @return
#' \code{vector_pop_back} does not return anything interesting. Throws an
#' error if a vector is empty.
vector_pop_back <- function(vec) {
    invisible(.Call('DataStructures_vector_pop_back', PACKAGE = 'DataStructures', vec))
}

#' @rdname vector
#' @details
#' \code{vector_at} returns an object at position i in the vector.
#'
#' @return
#' \code{vector_at} returns a single RObject value.
#'
#' @param i position i in the vector
vector_at <- function(vec, i) {
    .Call('DataStructures_vector_at', PACKAGE = 'DataStructures', vec, i)
}

#' @rdname vector
#' @details
#' \code{vector_set_at} sets an object obj at position i in the vector.
#'
#' @return
#' \code{vector_set_at} does not return anything interesting.
#'
#' @param i position i in the vector
#' @param obj an R object
vector_set_at <- function(vec, i, obj) {
    invisible(.Call('DataStructures_vector_set_at', PACKAGE = 'DataStructures', vec, i, obj))
}

hierarchical <- function(distance, listobj, isSimilarity = FALSE, m = 2L, minm = 4L, maxLeafPointsCount = 25L, vantageCandidatesCount = 5L, testPointsCount = 15L) {
    .Call('DataStructures_hierarchical', PACKAGE = 'DataStructures', distance, listobj, isSimilarity, m, minm, maxLeafPointsCount, vantageCandidatesCount, testPointsCount)
}

#' @rdname vptree
#' @details
#' \code{vptree_create} creates an empty vp-tree instance. Please use
#' \code{vptree_build} for populating the tree.
#'
#' @return
#' \code{vptree_create} returns a new, empty vp-tree.
#' @param distance an R function, which calculates metric in the space
#' @param isSimilarity a logical value, does a distance function calculate
#' distance or similarity?
#' @param m single integer, maximum number of children can be in a node
#' in the tree
#' @param minm single integer, minimum number of children can be in a node
#' in the tree
#' @param maxLeafPointsCount single integer, maximum number of
#' points in a single leaf
#' @param vantageCandidatesCount single integer, number of candidates
#' considered as a vantage point in a single node. Too big number can
#' cause performance problem in building the tree, but too small can cause
#' performance problem when searching.
#' @param testPointsCount single integer, how many points are considered with
#' a single candidate for vantage point in a node to assess a variance of
#' distances
vptree_create <- function(distance, isSimilarity = FALSE, m = 2L, minm = 4L, maxLeafPointsCount = 25L, vantageCandidatesCount = 5L, testPointsCount = 15L) {
    .Call('DataStructures_vptree_create', PACKAGE = 'DataStructures', distance, isSimilarity, m, minm, maxLeafPointsCount, vantageCandidatesCount, testPointsCount)
}

#' @rdname vptree
#' @details
#' \code{vptree_insert} inserts a new point into a vp-tree.
#' Calling this function n times has worse performance in comparison
#' to calling one \code{vptree_build} with n points in the beginning.
#'
#' @return
#' \code{vptree_insert} does not return anything interesting.
#' @param obj a point to insert
vptree_insert <- function(tree, obj) {
    invisible(.Call('DataStructures_vptree_insert', PACKAGE = 'DataStructures', tree, obj))
}

#' @rdname vptree
#' @details
#' \code{vptree_set_distancefunction} sets a metric function for a tree.
#' Setting this function after building a tree will cause problems. Do not
#' use if you do not know what you are doing.
#'
#' @return
#' \code{vptree_set_distancefunction} does not return anything interesting.
#' @param distance an R function, which calculates metric in the space
#' @param isSimilarity a logical value, does a distance function calculate
#' distance or similarity?
vptree_set_distancefunction <- function(tree, distance, isSimilarity = FALSE) {
    invisible(.Call('DataStructures_vptree_set_distancefunction', PACKAGE = 'DataStructures', tree, distance, isSimilarity))
}

#' @rdname vptree
#' @details
#' \code{vptree_build} populates an empty tree with set of points. If called
#' for non-empty tree, whole structure of previous tree is deleted. This is
#' recommended way of building a tree (instead of inserts by
#' \code{vptree_insert}).
#'
#' @return
#' \code{vptree_build} does not return anything interesting.
#' @param listobj an R list, where every element of list is assumed as one
#' point in a  metric space
vptree_build <- function(tree, listobj) {
    invisible(.Call('DataStructures_vptree_build', PACKAGE = 'DataStructures', tree, listobj))
}

#' @rdname vptree
#' @details
#' \code{vptree_searchKNN} finds k nearest neighbours for a given object
#' in the tree.
#' Please use this function for objects, which are not in a set of points
#' inserted to the tree or which were used for building the tree. For these
#' cases please use \code{vptree_searchKNNKnown} or
#' \code{vptree_searchKNNKnownIndex} which can be faster.
#'
#' @return
#' \code{vptree_searchKNN} returns a list. First element of the list
#' is a list with found elements. A second element of the list is a list
#' with distances these objects from a given object.
#' @param p an R object for which neighbours are found
#' @param k a single integer, number of neighbours to find
#' @param findItself boolean value, should results contain an given object?
vptree_searchKNN <- function(tree, p, k, findItself = TRUE) {
    .Call('DataStructures_vptree_searchKNN', PACKAGE = 'DataStructures', tree, p, k, findItself)
}

#' @rdname vptree
#' @details
#' \code{vptree_searchKNNKnown} finds k nearest neighbours for a given object
#' in the tree which was used for building the tree or inserted after that.
#' Please do not use this function for objects, which are "new" in a metric
#' space. This function can be faster than \code{vptree_searchKNN}.
#'
#' @return
#' \code{vptree_searchKNNKnown} returns a list. First element of the list
#' is a list with found elements. A second element of the list is a list
#' with distances these objects from a given object.
#' @param p an R object for which neighbours are found
#' @param k a single integer, number of neighbours to find
#' @param findItself boolean value, should results contain an given object?
vptree_searchKNNKnown <- function(tree, p, k, findItself = TRUE) {
    .Call('DataStructures_vptree_searchKNNKnown', PACKAGE = 'DataStructures', tree, p, k, findItself)
}

#' @rdname vptree
#' @details
#' \code{vptree_searchKNN} finds k nearest neighbours for a given index of
#' the object in space. Indices are as in a list given for building a tree.
#' For inserted objects they are pushed back at the end.
#' Please do not use this function for objects, which are "new" in a metric
#' space. This function can be faster than \code{vptree_searchKNN} and
#' \code{vptree_searchKNNKnown}. Indexing starts with 1, as in R language.
#'
#' @return
#' \code{vptree_searchKNNKnown} returns a list. First element of the list
#' is a list with found elements. A second element of the list is a list
#' with distances these objects from a given object.
#' @param index index of an object in the space
#' @param k a single integer, number of neighbours to find
#' @param findItself boolean value, should results contain an given object?
vptree_searchKNNKnownIndex <- function(tree, index, k, findItself = TRUE) {
    .Call('DataStructures_vptree_searchKNNKnownIndex', PACKAGE = 'DataStructures', tree, index, k, findItself)
}

#' @rdname vptree
#' @details
#' \code{vptree_searchRadius} finds neighbours for a given object
#' within a given radius in the tree.
#' Please use this function for objects, which are not in a set of points
#' inserted to the tree or which were used for building the tree. For these
#' cases please use \code{vptree_searchRadiusKnown} or
#' \code{vptree_searchRadiusKnownIndex} which can be faster.
#'
#' @return
#' \code{vptree_searchRadius} returns a list. First element of the list
#' is a list with found elements. A second element of the list is a list
#' with distances these objects from a given object.
#' @param p an R object for which neighbours are found
#' @param tau a float value, a radius
#' @param findItself boolean value, should results contain an given object?
vptree_searchRadius <- function(tree, p, tau, findItself = TRUE) {
    .Call('DataStructures_vptree_searchRadius', PACKAGE = 'DataStructures', tree, p, tau, findItself)
}

#' @rdname vptree
#' @details
#' \code{vptree_searchRadiusKnown} finds nearest neighbours for a given object
#' within a given radius
#' in the tree which was used for building the tree or inserted after that.
#' Please do not use this function for objects, which are "new" in a metric
#' space. This function can be faster than \code{vptree_searchRadius}.
#'
#' @return
#' \code{vptree_searchRadiusKnown} returns a list. First element of the list
#' is a list with found elements. A second element of the list is a list
#' with distances these objects from a given object.
#' @param p an R object for which neighbours are found
#' @param tau a float value, a radius
#' @param findItself boolean value, should results contain an given object?
vptree_searchRadiusKnown <- function(tree, p, tau, findItself = TRUE) {
    .Call('DataStructures_vptree_searchRadiusKnown', PACKAGE = 'DataStructures', tree, p, tau, findItself)
}

#' @rdname vptree
#' @details
#' \code{vptree_searchRadiusKnownIndex} finds nearest neighbours
#' for a given index of the object in space
#' within a given radius . Indices are as in a list given for building a tree.
#' For inserted objects they are pushed back at the end.
#' Please do not use this function for objects, which are "new" in a metric
#' space. This function can be faster than \code{vptree_searchRadius} and
#' \code{vptree_searchRadiusKnown}. Indexing starts with 1, as in R language.
#'
#' @return
#' \code{vptree_searchRadiusKnownIndex} returns a list. First element of the list
#' is a list with found elements. A second element of the list is a list
#' with distances these objects from a given object.
#' @param index index of an object in the space
#' @param tau a float value, a radius
#' @param findItself boolean value, should results contain an given object?
vptree_searchRadiusKnownIndex <- function(tree, index, tau, findItself = TRUE) {
    .Call('DataStructures_vptree_searchRadiusKnownIndex', PACKAGE = 'DataStructures', tree, index, tau, findItself)
}

#' @rdname vptree
#' @details
#' \code{vptree_getItems} returns a list of points in it.
#'
#' @return
#' \code{vptree_getItems} returns a list.
vptree_getItems <- function(vptree) {
    .Call('DataStructures_vptree_getItems', PACKAGE = 'DataStructures', vptree)
}

#' @rdname vptree
#' @details
#' \code{vptree_getFunction} returns a metric function used in the tree.
#'
#' @return
#' \code{vptree_getFunction} returns a function.
vptree_getFunction <- function(vptree) {
    .Call('DataStructures_vptree_getFunction', PACKAGE = 'DataStructures', vptree)
}

#' @rdname vptree
#' @details
#' \code{vptree_serialize} saves a structure of a tree to a file.
#' This function do not save a list of points or metric function. For saving whole
#' tree please use \code{vptree_save}. Do not use this function unless you know what
#' you are doing.
#'
#' @return
#' \code{vptree_getFunction} does not return anything interesting.
#' @param filename a path to file in which a strucutre of a tree will be saved.
vptree_serialize <- function(vptree, filename) {
    invisible(.Call('DataStructures_vptree_serialize', PACKAGE = 'DataStructures', vptree, filename))
}

#' @rdname vptree
#' @details
#' \code{vptree_read} loads a structure of a tree from a file.
#' This function do not load a list of points or metric function. For loading whole
#' tree please use \code{vptree_load}. Do not use this function unless you know what
#' you are doing.
#'
#' @return
#' \code{vptree_read} does not return anything interesting.
#' @param filename a path to file in which a strucutre of a tree is saved.
vptree_read <- function(filename) {
    .Call('DataStructures_vptree_read', PACKAGE = 'DataStructures', filename)
}

#' @rdname vptree
#' @details
#' \code{vptree_setItems} sets a set of points in metric space. Using this
#' function after building a tree will cause problems. Do not use this function
#' unless you know what you are doing.
#'
#' @return
#' \code{vptree_setItems} does not return anything interesting.
#' @param items a list of points.
vptree_setItems <- function(vptree, items) {
    invisible(.Call('DataStructures_vptree_setItems', PACKAGE = 'DataStructures', vptree, items))
}

#' @rdname vptree
#' @details
#' \code{vptree_setMetricFunction} sets metric function. Using this
#' function after building a tree will cause problems. Do not use this function
#' unless you know what you are doing.
#'
#' @return
#' \code{vptree_setMetricFunction} does not return anything interesting.
#' @param f a metric function.
vptree_setMetricFunction <- function(vptree, f) {
    invisible(.Call('DataStructures_vptree_setMetricFunction', PACKAGE = 'DataStructures', vptree, f))
}

#' @rdname vptree
#' @details
#' \code{vptree_treeSize} returns the size of a tree. To returned value adding
#' a size of RObjects in space is needed. In other words, this function
#' returns size of all nodes in tree (and a tree itself),
#' including indices of points in space,
#' size of pointers, radiuses etc., but no points (RObjects) underlying.
#'
#'
#' @return
#' \code{vptree_treeSize} returns a size in bytes of a vp-tree.
vptree_treeSize <- function(vptree) {
    .Call('DataStructures_vptree_treeSize', PACKAGE = 'DataStructures', vptree)
}

#' @rdname vptree
#' @details
#' \code{vptree_treeSize} returns the height of a tree.
#'
#' @return
#' \code{vptree_treeSize} returns the height of a tree.
vptree_treeHeight <- function(vptree) {
    .Call('DataStructures_vptree_treeHeight', PACKAGE = 'DataStructures', vptree)
}

#' @rdname vptree
#' @details
#' \code{vptree_printCounters} prints how many hits every element in hashmap got.
#'
#' @return
#' \code{vptree_printCounters} does not return anything interesting.
vptree_printCounters <- function(vptree) {
    invisible(.Call('DataStructures_vptree_printCounters', PACKAGE = 'DataStructures', vptree))
}

